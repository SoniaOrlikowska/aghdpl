\chapter{Conclusions}\label{cha:Conclusions}
This chapter presents the conclusions of the results obtained during this study. This thesis succesfuly created a framework which allows to parametrise 
three maze solvers: Binary Tree, Aldous-Broder and Recursive-Backtracker, and three maze generators: BFS, Dijkstra and Astar.
Seven maze parameters were evaluated along with two different complexity measures. It was possible to compare obtained data with other works. After the
results following answers to the research question are submitted:
\begin{enumerate}
    \item [Q1.] What is the relation between the maze features, generated by Binary Tree, Aldous-Broder and Recursive-Backtracker algorithms,
     and their completion time obtained, when solved using a BFS, Dijkstra and $A^*$ algorithms?\\
     Solution time for perfect mazes with longer subsidiary paths, and cycled-directed mazes with higher fork and intersection ratios, such as Binary Tree,
     identify to have longer solution time.
    \item [Q2.] Which maze parameters best describe the complexity of a problem in terms of time completion?\\
    Shanon's Entropy seems to be the most accurate predicate of maze complexity, independent of maze size. 
    \item [Q3.] Which maze features are the best to distinguish different types of mazes?\\
    The best maze feature to distinguish Binary Tree, Aldous-Broder and Recursive-Backtracker is cross number to dead-end number, both 
    for perfect mazes and mazes with added cycles and directions.
\end{enumerate}
\indent For this work a lightweight web apllication in JavaScript was developed to present discussed algorithms and the results collected during this study.
All main outlined objectives for this application were realised. Application allows verification of the described parameters affecting the appearance of
the maze, its solutions and the required solution time on a dedicated charts, tables and figures. The application and its repository is available publicly.\newline
Each application user can:\\
$-$ generate a maze using the following algorithms: Binary Tree, Aldous-Broder, Recursive-Backtracker,\\
$-$ add cycles and directed cells to previously generated maze using the UI and interactive canvas,\\
$-$ solve the maze using the following algorithms: Dijkstra, $A^*$, BFS,\\
$-$ observe how maze complexity and cross to dead-end ratio changes for each maze,\\
$-$ collect and download detailed informations of generated mazes and solutions.\\




